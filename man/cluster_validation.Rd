% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_validation.R,
%   R/cluster_validation_plot.R, R/cluster_validation_print.R,
%   R/cluster_validation_summary.R, R/fix_cluster_labels.R,
%   R/plot_distributions.R
\name{cluster_validation}
\alias{cluster_validation}
\alias{plot.clustervalidation}
\alias{print.clustervalidation}
\alias{summary.clustervalidation}
\alias{plot.cv_summary}
\alias{fix_cluster_labels}
\alias{plot_distributions}
\title{Cluster profile validation}
\usage{
cluster_validation(
  df,
  n_clusters = 2,
  cluster_fun = stats::kmeans,
  get_cluster_fun = function(x) {
     x$cluster
 },
  oob_predict_fun = function(fit, newdata) {
     predict(fit, newdata = newdata)
 },
  summary_fun = mean,
  n_samples = 100,
  sample_size = 0.5 * nrow(df),
  replace = FALSE,
  standardize = TRUE,
  seed,
  verbose = interactive(),
  ...
)

\method{plot}{clustervalidation}(
  x,
  plot_complete = TRUE,
  plot_in_sample = TRUE,
  plot_oob_sample = TRUE,
  point_alpha = 0.1,
  point_size = 1,
  line_alpha = 0.1,
  line_width = 1,
  complete_color = "blue",
  complete_size = 1,
  complete_point_size = 2,
  xlab = "",
  ylab = ifelse(attr(x, "standardize"), "Mean Standard Score", "Mean Score"),
  ...
)

\method{print}{clustervalidation}(x, ...)

\method{summary}{clustervalidation}(object, in_sample = FALSE, oob_sample = TRUE, ...)

\method{plot}{cv_summary}(x, ...)

fix_cluster_labels(
  cv,
  greedy = (length(unique(cv$oob_sample$cluster)) > 7),
  var,
  ...
)

plot_distributions(
  cv,
  plot_in_sample = TRUE,
  plot_oob_sample = FALSE,
  nrow = NULL,
  palette = 2,
  ...
)
}
\arguments{
\item{df}{data frame to estimate clusters. Note that all columns will be used
in the estimation.}

\item{n_clusters}{the number of clusters to estimate.}

\item{cluster_fun}{the function used to estimate the clusters.}

\item{get_cluster_fun}{the function used to get the cluster classes. This function
takes one parameter, the result of \code{cluster_fun}.}

\item{oob_predict_fun}{the function used to get predictions from the out-of-bag
sample. Function takes two parameters, the first is the results of
\code{cluster_fun}, the second is the  out-of-bag sample data frame.}

\item{summary_fun}{the function used to calculate the statistic for each
cluster and iteration. Defaults to \code{mean}.}

\item{n_samples}{the number of random samples to draw.}

\item{sample_size}{the size of each random sample. Defaults to 50\% of observations.}

\item{replace}{whether sampling should be done with replacement.}

\item{standardize}{whether the variables should be standardized before
estimating clusters.}

\item{seed}{random number seed. Note that the seed is set before each iteration
to \code{seed + i} where \code{i} is the iteration number.}

\item{verbose}{whether the function should print the status while running.}

\item{...}{currently not used.}

\item{x}{result of \code{summary.clustervalidation()}}

\item{plot_complete}{whether the profile line using the complete data set
should be plotted.}

\item{plot_in_sample}{whether to plot the in sample (i.e. bootstrap) distributions.}

\item{plot_oob_sample}{whether to plot the out-of-bag samples.}

\item{point_alpha}{the alpha (transparency) level for points.}

\item{point_size}{the size of the points.}

\item{line_alpha}{the alpha (transparency) level for lines.}

\item{line_width}{width of the lines.}

\item{complete_color}{the color of the path for the path using the complete dataset
(i.e. \code{plot_complete = TRUE})}

\item{complete_size}{the size of the path for the path using the complete dataset
(i.e. \code{plot_complete = TRUE})}

\item{complete_point_size}{the point size of the path for the path using the complete dataset
(i.e. \code{plot_complete = TRUE})}

\item{xlab}{label for the x-axis.}

\item{ylab}{label for the y-axis.}

\item{object}{the results of \code{cluster_validation}.}

\item{in_sample}{plot the in sample results.}

\item{oob_sample}{plot the out-of-bag sample results.}

\item{cv}{the results from \code{\link[=cluster_validation]{cluster_validation()}}.}

\item{greedy}{if \code{FALSE} this will find the optimal cluster pattern by calculating difference
for all combinations. If \code{TRUE} this will consider only one variable (the one with the
largest variance across means).}

\item{var}{the variable to use if \code{greedy = TRUE}.}

\item{nrow}{number of rows. This is ignored if \code{plot_in_sample = TRUE} and \code{plot_oob_sample = TRUE}.}

\item{palette}{If a string, will use that named palette. If a number, will index into the list of
palettes of appropriate type. See \code{\link[ggplot2:scale_brewer]{ggplot2::scale_color_brewer()}} for more information.}
}
\value{
a list with the following elements:
\describe{
\item{complete_sample}{data frame of results using the entire data set.}
\item{in_sample}{data frame of in sample results.}
\item{oob_sample}{data frame of out-of-bag results.}
\item{complete_model_fit}{model fit for the full data set.}
\item{in_sample_model_fits}{model fits for each sample.}
}
Each of these data frames contain four columns:
\describe{
\item{iter}{the iteration}
\item{cluster}{the cluster}
\item{variable}{the variable}
\item{value}{the mean value of \code{variable} for the given cluster and interation}
}

a ggplot2 expression.

a ggplot2 expression.

the \code{cv} object with the cluster labels in the \code{oob_sample} data frame reassigned so
that the labels match across all iterations as best as possible.

a \code{ggplot2} expression.
}
\description{
This function takes multiple random samples from the provided data frame,
estimate cluster membership, and calculate the mean (the default, a different
statistic can be specified using the \code{summary_fun} parameter, e.g. \code{median}
may be appropriate) for each cluster using both the in sample and out-of-bag
(i.e. out of sample). For the out-of-bag sample

This function will re-assign cluster labels such that the mean absolute difference to the the
cluster labels from the full dataset is as small as possible.
}
\details{
The number of rows in the resulting data frames will be equal to:
\code{ncol(df) * n_samples * n_clusters}.
}
